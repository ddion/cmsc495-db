/*
 * Course:  CMSC495 - Trends and Projects in Computer Science
 * Project: Splatter - Team 1
 * Author:  Michael Songy
 * Date:    10/15/2011
 * Platform:
 *  PostgreSQL 9.1
 *  Ubuntu 11.10
 *
 * File:    create_functions.postgresql
 * Purpose: This file creates the functions to interface with the database.
 */

/*
 * Load the PL/pgSQL language.
 */
set SEARCH_PATH to PUBLIC;

create extension if not exists PLPGSQL;

/*
 * Create the schema.
 */
drop schema if exists SPLATTER_API cascade;

create schema SPLATTER_API;

set SEARCH_PATH to SPLATTER_API, SPLATTER, PUBLIC;

/*
 * Adds a user record to the database.
 */
create function CREATE_USER(
       P_USERNAME_IN           VARCHAR,
       P_PASSWORD_IN           VARCHAR,
       P_FIRST_IN              VARCHAR,
       P_MI_IN                 CHAR(1),
       P_LAST_IN               VARCHAR,
       P_NAME_PRIVACY_IN       ACCESS_LEVEL,
       P_EMAIL_IN              VARCHAR,
       P_EMAIL_PRIVACY_IN      ACCESS_LEVEL)
  returns BIGINT as $$
declare
  V_USER_ID          BIGINT;
begin
  -- Insert the user.
  insert into SPLATTER.USERS(
    CREATED_TIME, UPDATED_TIME,
    USERNAME, PASSWORD,
    FIRST, MI, LAST, NAME_PRIVACY,
    EMAIL, EMAIL_PRIVACY)
  values (
    CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
    P_USERNAME_IN, P_PASSWORD_IN,
    P_FIRST_IN, P_MI_IN, P_LAST_IN, P_NAME_PRIVACY_IN,
    P_EMAIL_IN, P_EMAIL_PRIVACY_IN)
  returning USER_ID into strict V_USER_ID;

  -- Return the new user id.
  return V_USER_ID;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves a user record from the database.
 */
create function RETREIVE_USER(
       P_USER_ID_IN            BIGINT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve the user.
  open C_RESULTS for
    select *
      from SPLATTER.USERS
     where USER_ID = P_USER_ID_IN;

  -- Return the results;
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Updates an existing user record in the database.
 */
create function UPDATE_USER(
       P_USER_ID_IN            BIGINT,
       P_USERNAME_IN           VARCHAR,
       P_PASSWORD_IN           VARCHAR,
       P_FIRST_IN              VARCHAR,
       P_MI_IN                 CHAR(1),
       P_LAST_IN               VARCHAR,
       P_NAME_PRIVACY_IN       ACCESS_LEVEL,
       P_EMAIL_IN              VARCHAR,
       P_EMAIL_PRIVACY_IN      ACCESS_LEVEL)
  returns VOID as $$
begin
  -- Update the user record.
  update SPLATTER.USERS
     set UPDATED_TIME = CURRENT_TIMESTAMP,
         USERNAME = P_USERNAME_IN,
         PASSWORD = P_PASSWORD_IN,
         FIRST = P_FIRST_IN,
         MI = P_MI_IN,
         LAST = P_LAST_IN,
         NAME_PRIVACY = P_NAME_PRIVACY_IN,
         EMAIL = P_EMAIL_IN,
         EMAIL_PRIVACY = P_EMAIL_PRIVACY_IN
   where USER_ID = P_USER_ID_IN;
end;
$$ language PLPGSQL security definer;

/*
 * Deletes a user record from the database.
 */
create function DELETE_USER(
       P_USER_ID_IN            BIGINT)
  returns VOID as $$
begin
  -- Delete the user record.
  delete
    from SPLATTER.USERS
   where USER_ID = P_USER_ID_IN;
end;
$$ language PLPGSQL security definer;

/*
 * Checks if one user is following another.
 */
create function IS_FOLLOWER(
       P_FOLLOWER_ID_IN        BIGINT,
       P_FOLLOWED_ID_IN        BIGINT)
  returns BOOLEAN as $$
declare
  V_IS_FOLLOWER      BOOLEAN = null;
begin
  -- Check if the connection exists.
  select true into V_IS_FOLLOWER
    from SPLATTER.CONNECTIONS
   where FOLLOWER_ID = P_FOLLOWER_ID_IN
     and FOLLOWED_ID = P_FOLLOWED_ID_IN;

  -- Return the result.
  if (V_IS_FOLLOWER is null) then
    return false;
  else
    return V_IS_FOLLOWER;
  end if;
end;
$$ language PLPGSQL security definer;

/*
 * Checks if one user has access to another's name.
 */
create function HAS_ACCESS(
       P_PRIVACY_IN            ACCESS_LEVEL,
       P_IS_FOLLOWER           BOOLEAN)
returns BOOLEAN as $$
begin
  return P_PRIVACY_IN = 'ALL' or (
           P_PRIVACY_IN = 'FOLLOWERS' and
           P_IS_FOLLOWER);
end;
$$ language PLPGSQL security definer;

/*
 * Allows a user to view another user's account.
 * The ID of the searching user must be supplied in order
 * to filter results according to privacy settings.
 */
create function VIEW_USER(
       P_VIEWER_ID_IN          BIGINT,
       P_USER_ID_IN            BIGINT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Find the user.
  open C_RESULTS for
    with PRIV_USERS as(
      select USER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               FOLLOWER_ID is not null) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               FOLLOWER_ID is not null) as EMAIL_PRIVACY,
             FOLLOWER_ID is not null as VIEWER_FOLLOWING_USER,
             SPLATTER_API.IS_FOLLOWER(
               USER_ID, P_VIEWER_ID_IN) as USER_FOLLOWING_VIEWER
        from SPLATTER.USERS
        left outer join SPLATTER.CONNECTIONS
          on P_VIEWER_ID_IN = FOLLOWER_ID
         and USER_ID = FOLLOWED_ID
       where USER_ID = P_USER_ID_IN)
    select USER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           VIEWER_FOLLOWING_USER,
           USER_FOLLOWING_VIEWER
      from PRIV_USERS;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves user records matching a name.
 * The ID of the searching user must be supplied in order
 * to filter results according to privacy settings.
 */
create function FIND_USER_BY_NAME(
       P_VIEWER_ID_IN          BIGINT,
       P_FIRST_IN              VARCHAR,
       P_MI_IN                 CHAR(1),
       P_LAST_IN               VARCHAR)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Find the user(s).
  open C_RESULTS for
    with PRIV_USERS as(
      select USER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               FOLLOWER_ID is not null) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               FOLLOWER_ID is not null) as EMAIL_PRIVACY,
             FOLLOWER_ID is not null as VIEWER_FOLLOWING_USER,
             SPLATTER_API.IS_FOLLOWER(
               USER_ID, P_VIEWER_ID_IN) as USER_FOLLOWING_VIEWER
        from SPLATTER.USERS
        left outer join SPLATTER.CONNECTIONS
          on P_VIEWER_ID_IN = FOLLOWER_ID
         and USER_ID = FOLLOWED_ID
       where NAME_PRIVACY
         and (P_FIRST_IN is not null or
              P_MI_IN is not null or
              P_LAST_IN is not null)
         and (P_FIRST_IN is null or P_FIRST_IN ilike FIRST)
         and (P_MI_IN is null or P_MI_IN ilike MI)
         and (P_LAST_IN is null or P_LAST_IN ilike LAST))
    select USER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           VIEWER_FOLLOWING_USER,
           USER_FOLLOWING_VIEWER
      from PRIV_USERS;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves user records matching a username.
 * The ID of the searching user must be supplied in order
 * to filter results according to privacy settings.
 */
create function FIND_USER_BY_USERNAME(
       P_VIEWER_ID_IN          BIGINT,
       P_USERNAME_IN           VARCHAR)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Find the user.
  open C_RESULTS for
    with PRIV_USERS as(
      select USER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               FOLLOWER_ID is not null) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               FOLLOWER_ID is not null) as EMAIL_PRIVACY,
             FOLLOWER_ID is not null as VIEWER_FOLLOWING_USER,
             SPLATTER_API.IS_FOLLOWER(
               USER_ID, P_VIEWER_ID_IN) as USER_FOLLOWING_VIEWER
        from SPLATTER.USERS
        left outer join SPLATTER.CONNECTIONS
          on P_VIEWER_ID_IN = FOLLOWER_ID
         and USER_ID = FOLLOWED_ID
       where USERNAME = P_USERNAME_IN)
    select USER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           VIEWER_FOLLOWING_USER,
           USER_FOLLOWING_VIEWER
      from PRIV_USERS;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves user records matching an email.
 * The ID of the searching user must be supplied in order
 * to filter results according to privacy settings.
 */
create function FIND_USER_BY_EMAIL(
       P_VIEWER_ID_IN          BIGINT,
       P_EMAIL_IN              VARCHAR)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Find the user.
  open C_RESULTS for
    with PRIV_USERS as(
      select USER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               FOLLOWER_ID is not null) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               FOLLOWER_ID is not null) as EMAIL_PRIVACY,
             FOLLOWER_ID is not null as VIEWER_FOLLOWING_USER,
             SPLATTER_API.IS_FOLLOWER(
               USER_ID, P_VIEWER_ID_IN) as USER_FOLLOWING_VIEWER
        from SPLATTER.USERS
        left outer join SPLATTER.CONNECTIONS
          on P_VIEWER_ID_IN = FOLLOWER_ID
         and USER_ID = FOLLOWED_ID
      where EMAIL = P_EMAIL_IN)
    select USER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           VIEWER_FOLLOWING_USER,
           USER_FOLLOWING_VIEWER
      from PRIV_USERS;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Adds an update record to the database.
 */
create function CREATE_UPDATE(
       P_USER_ID_IN            BIGINT,
       P_MESSAGE_IN            VARCHAR(280))
  returns BIGINT as $$
declare
  V_UPDATE_ID        BIGINT;
begin
  -- Insert the update.
  insert into SPLATTER.UPDATES(
    USER_ID,
    CREATED_TIME, UPDATED_TIME,
    POSTED, MESSAGE)
  values (
    P_USER_ID_IN,
    CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
    false, P_MESSAGE_IN)
  returning UPDATE_ID into strict V_UPDATE_ID;

  -- Return the new update id.
  return V_UPDATE_ID;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves an update record from the database.
 */
create function RETRIEVE_UPDATE(
       P_UPDATE_ID_IN          BIGINT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve the update.
  open C_RESULTS for
    select *
      from SPLATTER.UPDATES
     where UPDATE_ID = P_UPDATE_ID_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves updates for the specified owning user.
 * Results are ordered reverse-chronologically.
 */
create function RETREIVE_UPDATES(
       P_OWNER_ID_IN           BIGINT,
       P_RESULTS_OFFSET_IN     INT,
       P_RESULTS_COUNT_IN      INT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retreive the updates.
  open C_RESULTS for
    select *
      from SPLATTER.UPDATES
     where USER_ID = P_OWNER_ID_IN
     order by UPDATED_TIME desc
     limit P_RESULTS_COUNT_IN
    offset P_RESULTS_OFFSET_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Saves an existing update record in the database.
 */
create function SAVE_UPDATE(
       P_UPDATE_ID_IN          BIGINT,
       P_MESSAGE_IN            VARCHAR(280))
  returns VOID as $$
begin
  -- Update the update.
  update SPLATTER.UPDATES
     set MESSAGE = P_MESSAGE_IN,
         UPDATED_TIME = CURRENT_TIMESTAMP
   where UPDATE_ID = P_UPDATE_ID_IN;
end;
$$ language PLPGSQL security definer;

/*
 * Posts an existing update record in the database.
 */
create function POST_UPDATE(
       P_UPDATE_ID_IN          BIGINT)
  returns VOID as $$
begin
  -- Delete the update.
  update SPLATTER.UPDATES
     set POSTED = true
   where UPDATE_ID = P_UPDATE_ID_IN;
end;
$$ language PLPGSQL security definer;

/*
 * Deletes an update record from the database.
 */
create function DELETE_UPDATE(
       P_UPDATE_ID_IN          BIGINT)
  returns VOID as $$
begin
  -- Delete the update.
  delete
    from SPLATTER.UPDATES
   where UPDATE_ID = P_UPDATE_ID_IN;
end;
$$ language PLPGSQL security definer;

/*
 * Finds updates from all users being followed.
 * Results are ordered reverse-chronologically.
 */
create function VIEW_FOLLOWED_UPDATES(
       P_VIEWER_ID_IN          BIGINT,
       P_RESULTS_OFFSET_IN     INT,
       P_RESULTS_COUNT_IN      INT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve the updates.
  open C_RESULTS for
    select UPDATE_ID,
           UPDATES.USER_ID as USER_ID,
           USERNAME,
           UPDATED_TIME as POSTED_TIME,
           MESSAGE
      from SPLATTER.UPDATES
      join SPLATTER.CONNECTIONS
      join SPLATTER.USERS
        on USER_ID = FOLLOWED_ID
     using (USER_ID)
     where POSTED
       and FOLLOWER_ID = P_VIEWER_ID_IN
     order by UPDATED_TIME desc
     limit P_RESULTS_COUNT_IN
    offset P_RESULTS_OFFSET_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Finds all updates from a specified user.
 * This function requires the ID of the viewing user in order
 * to respect privacy settings.
 * Results are ordered reverse-chronologically.
 */
create function VIEW_USER_UPDATES(
       P_VIEWER_ID_IN          BIGINT,
       P_OWNER_ID_IN           BIGINT,
       P_RESULTS_OFFSET_IN     INT,
       P_RESULTS_COUNT_IN      INT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve the updates.
  open C_RESULTS for
    select UPDATE_ID,
           UPDATES.USER_ID as USER_ID,
           USERNAME,
           UPDATED_TIME as POSTED_TIME,
           MESSAGE
      from SPLATTER.UPDATES
      join SPLATTER.CONNECTIONS
      join SPLATTER.USERS
        on USER_ID = FOLLOWED_ID
     using (USER_ID)
     where POSTED
       and USER_ID = P_OWNER_ID_IN
       and FOLLOWER_ID = P_VIEWER_ID_IN
     order by UPDATED_TIME desc
     limit P_RESULTS_COUNT_IN
    offset P_RESULTS_OFFSET_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Adds a connection request record to the database.
 */
create function CREATE_CONNECTION_REQUEST(
       P_SENDER_ID_IN          BIGINT,
       P_RECEIVER_ID_IN        BIGINT,
       P_MESSAGE_IN            VARCHAR(280))
  returns BIGINT as $$
declare
  V_REQUEST_ID       BIGINT;
begin
  -- Insert the request and return the new request id.
  insert into SPLATTER.CONNECTION_REQUESTS(
    SENDER_ID, RECEIVER_ID,
    CREATED_TIME,
    MESSAGE)
  values (
    P_SENDER_ID_IN, P_RECEIVER_ID_IN,
    CURRENT_TIMESTAMP,
    P_MESSAGE_IN)
  returning REQUEST_ID into V_REQUEST_ID;

  -- Return the new request id.
  return V_REQUEST_ID;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves a connection request record from the database.
 */
create function RETRIEVE_CONNECTION_REQUEST(
       P_REQUEST_ID_IN         BIGINT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve the request.
  open C_RESULTS for
    select *
      from SPLATTER.CONNECTION_REQUESTS
     where REQUEST_ID = P_REQUEST_ID_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Accepts a connection request, deleting the connection
 * request record and adding a new connection record.
 */
create function ACCEPT_CONNECTION_REQUEST(
       P_REQUEST_ID            BIGINT)
  returns BIGINT as $$
declare
  V_CONNECTION_ID    BIGINT;
  V_FOLLOWER_ID      BIGINT;
  V_FOLLOWED_ID      BIGINT;
begin
  -- Delete the request.
  delete
    from SPLATTER.CONNECTION_REQUESTS
   where REQUEST_ID = P_REQUEST_ID
  returning SENDER_ID, RECEIVER_ID
    into strict V_FOLLOWER_ID, V_FOLLOWED_ID;

  -- Add the new connection.
  insert into CONNECTIONS(
    FOLLOWER_ID, FOLLOWED_ID,
    CREATED_TIME)
  values(
    V_FOLLOWER_ID, V_FOLLOWED_ID,
    CURRENT_TIMESTAMP)
  returning CONNECTION_ID 
  into strict V_CONNECTION_ID;

  -- Return the connection id.
  return V_CONNECTION_ID;
end;
$$ language PLPGSQL security definer;

/*
 * Rejects a connection request, deleting the record
 * from the database.
 */
create function REJECT_CONNECTION_REQUEST(
       P_REQUEST_ID_IN         BIGINT)
  returns VOID as $$
begin
  -- Delete the request.
  delete
    from SPLATTER.CONNECTION_REQUESTS
   where REQUEST_ID = P_REQUEST_ID_IN;
end;
$$ language PLPGSQL security definer;

/*
 * Deletes a connection request record from the database.
 */
create function DELETE_CONNECTION_REQUEST(
       P_REQUEST_ID_IN         BIGINT)
  returns VOID as $$
begin
  -- Delete the request.
  delete
    from SPLATTER.CONNECTION_REQUESTS
   where REQUEST_ID = P_REQUEST_ID_IN;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves connection requests for the specified receiving user.
 * Results are ordered reverse-chronologically.
 */
create function VIEW_RECEIVED_CONNECTION_REQUESTS(
       P_RECEIVER_ID_IN        BIGINT,
       P_RESULTS_OFFSET_IN     INT,
       P_RESULTS_COUNT_IN      INT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve the requests.
  open C_RESULTS for
    with PRIV_USERS as (
      select REQUEST_ID,
             SENDER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               FOLLOWER_ID is not null) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               FOLLOWER_ID is not null) as EMAIL_PRIVACY,
             FOLLOWER_ID is not null as RECEIVER_FOLLOWING_SENDER,
             CONNECTION_REQUESTS.CREATED_TIME as CREATED_TIME
        from SPLATTER.CONNECTION_REQUESTS
        join SPLATTER.USERS
          on USER_ID = SENDER_ID
         and P_RECEIVER_ID_IN = RECEIVER_ID
        left outer join SPLATTER.CONNECTIONS
          on P_RECEIVER_ID_IN = FOLLOWER_ID
         and USER_ID = FOLLOWED_ID)
    select REQUEST_ID,
           SENDER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           RECEIVER_FOLLOWING_SENDER,
           CREATED_TIME
      from PRIV_USERS
     order by CREATED_TIME desc
     limit P_RESULTS_COUNT_IN
    offset P_RESULTS_OFFSET_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves connection requests for the specified sending user.
 * Results are ordered reverse-chronologically.
 */
create function VIEW_SENT_CONNECTION_REQUESTS(
       P_SENDER_ID_IN          BIGINT,
       P_RESULTS_OFFSET_IN     INT,
       P_RESULTS_COUNT_IN      INT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve the requests.
  open C_RESULTS for
    with PRIV_USERS as (
      select REQUEST_ID,
             RECEIVER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               FOLLOWER_ID is not null) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               FOLLOWER_ID is not null) as EMAIL_PRIVACY,
             FOLLOWER_ID is not null as SENDER_FOLLOWING_RECEIVER,
             SPLATTER_API.IS_FOLLOWER(
               RECEIVER_ID, P_SENDER_ID_IN) as RECEIVER_FOLLOWING_SENDER,
             CONNECTION_REQUESTS.CREATED_TIME as CREATED_TIME
        from SPLATTER.CONNECTION_REQUESTS
        join SPLATTER.USERS
          on P_SENDER_ID_IN = SENDER_ID
         and USER_ID = RECEIVER_ID
        left outer join SPLATTER.CONNECTIONS
          on P_SENDER_ID_IN = FOLLOWER_ID
         and USER_ID = FOLLOWED_ID)
    select REQUEST_ID,
           RECEIVER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           SENDER_FOLLOWING_RECEIVER,
           RECEIVER_FOLLOWING_SENDER,
           CREATED_TIME
      from PRIV_USERS
     order by CREATED_TIME desc
     limit P_RESULTS_COUNT_IN
    offset P_RESULTS_OFFSET_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves records of users who are being followed by
 * the specified user.
 * Results are ordered lexicographically by username.
 */
create function VIEW_FOLLOWED_USERS(
       P_VIEWER_ID_IN          BIGINT,
       P_RESULTS_OFFSET_IN     INT,
       P_RESULTS_COUNT_IN      INT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve followed users.
  open C_RESULTS for
    with PRIV_USERS as (
      select USER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               true) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               true) as EMAIL_PRIVACY,
             C2.FOLLOWER_ID is not null as USER_FOLLOWING_VIEWER,
             C1.CREATED_TIME as CREATED_TIME
        from SPLATTER.CONNECTIONS as C1
        join SPLATTER.USERS
          on P_VIEWER_ID_IN = C1.FOLLOWER_ID
         and USER_ID = C1.FOLLOWED_ID
        left outer join SPLATTER.CONNECTIONS as C2
          on USER_ID = C2.FOLLOWER_ID
         and P_VIEWER_ID_IN = C2.FOLLOWED_ID)
    select USER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           USER_FOLLOWING_VIEWER,
           CREATED_TIME
      from PRIV_USERS
     order by CREATED_TIME desc
     limit P_RESULTS_COUNT_IN
    offset P_RESULTS_OFFSET_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;

/*
 * Retrieves records of users who are following the specified user.
 * Results are ordered lexicographically by username.
 */
create function VIEW_FOLLOWERS(
       P_VIEWER_ID_IN          BIGINT,
       P_RESULTS_OFFSET_IN     INT,
       P_RESULTS_COUNT_IN      INT)
  returns REFCURSOR as $$
declare
  C_RESULTS          REFCURSOR;
begin
  -- Retrieve followers.
  open C_RESULTS for
    with PRIV_USERS as (
      select USER_ID, USERNAME,
             FIRST, MI, LAST,
             SPLATTER_API.HAS_ACCESS(
               NAME_PRIVACY,
               C2.FOLLOWER_ID is not null) as NAME_PRIVACY,
             EMAIL,
             SPLATTER_API.HAS_ACCESS(
               EMAIL_PRIVACY,
               C2.FOLLOWER_ID is not null) as EMAIL_PRIVACY,
             C2.FOLLOWER_ID is not null as VIEWER_FOLLOWING_USER,
             C1.CREATED_TIME as CREATED_TIME
        from SPLATTER.CONNECTIONS as C1
        join SPLATTER.USERS
          on USER_ID = C1.FOLLOWER_ID
         and P_VIEWER_ID_IN = C1.FOLLOWED_ID
        left outer join SPLATTER.CONNECTIONS as C2
          on P_VIEWER_ID_IN = C2.FOLLOWER_ID
         and USER_ID = C2.FOLLOWED_ID)
    select USER_ID, USERNAME,
           case when NAME_PRIVACY
                then FIRST
                else null
           end as FIRST,
           case when NAME_PRIVACY
                then MI
                else null
           end as MI,
           case when NAME_PRIVACY
                then LAST
                else null
           end as LAST,
           NAME_PRIVACY,
           case when EMAIL_PRIVACY
                then EMAIL
                else null
           end as EMAIL,
           EMAIL_PRIVACY,
           USER_FOLLOWING_VIEWER,
           CREATED_TIME
      from PRIV_USERS
     order by CREATED_TIME desc
     limit P_RESULTS_COUNT_IN
    offset P_RESULTS_OFFSET_IN;

  -- Return the results.
  return C_RESULTS;
end;
$$ language PLPGSQL security definer;
